<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Badger 2-3 Reforged</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="attackdefend/gamemode.html"><strong aria-hidden="true">1.</strong> Game Mode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attackdefend/faction_config.html"><strong aria-hidden="true">1.1.</strong> Faction Config</a></li><li class="chapter-item expanded "><a href="attackdefend/spawnarea.html"><strong aria-hidden="true">1.2.</strong> Spawn Area</a></li><li class="chapter-item expanded "><a href="attackdefend/poi.html"><strong aria-hidden="true">1.3.</strong> POI</a></li><li class="chapter-item expanded "><a href="attackdefend/attackdefend.html"><strong aria-hidden="true">1.4.</strong> Attack &amp; Defend</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Badger 2-3 Reforged</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="base-gamemode"><a class="header" href="#base-gamemode">Base Gamemode</a></h1>
<p>For my purposes I just want to create a gamemode class that can store <code>SpawnAreas</code> as well as <code>Points of Interest</code> along with appropriate APIs to register/unregister amongst a few other things.</p>
<pre><code class="language-csharp">[EntityEditorProps(category: &quot;GameScripted/Gamemode&quot;, description: &quot;Badger's basic game-mode.&quot;, color: &quot;0 0 255 255&quot;)]
class SCR_Badger_BaseGameModeClass : SCR_BaseGameModeComponentClass
{
};

class SCR_Badger_BaseGameMode : SCR_BaseGameModeComponent
{
    // Actual code will go here
};
</code></pre>
<p>This is all we need to make this class appear in the Enfusion Editor as a component we can add to <code>SCR_BaseGameMode</code>.</p>
<ol>
<li>
<p>Place a <code>SCR_BaseGameMode</code> into the world.
<img src="attackdefend/../imgs/attackdefend/create-entity-step1.png" alt="Create Entity" /></p>
</li>
<li>
<p>Click on the <code>SCR_BaseGameMode</code> entity and <code>AddComponent</code></p>
</li>
<li>
<p>Select <code>SCR_Badger_BaseGameMode</code>, or whatever you called yours... if you're following along...</p>
</li>
</ol>
<p>Now you should have it appear in the entity hierarchy
<img src="attackdefend/../imgs/attackdefend/entity-hierarchy.png" alt="Entity Hierarchy" /></p>
<h2 id="singleton"><a class="header" href="#singleton">Singleton</a></h2>
<p>This will behave as a centralized place for any other subsystem. For my uses I'd like to store Faction <code>SpawnAreas</code> along with <code>Points of Interest</code>. Both of these are entities which will automatically register themselves which will require an API. So lets get cracking....</p>
<p>External entities will need a way to access our gamemode API. There should only ever be <strong>one</strong> instance. Thus, a singleton approach is perfect.</p>
<pre><code class="language-csharp">// Singleton, assigned on first 'get'
static SCR_Badger_BaseGameMode s_pInstance;

// Retrieves existing instance of gamemode, if it exists...
SCR_Badger_BaseGameMode GetInstance()
{
    BaseGameMode gameMode = GetGame().GetGameMode();
    if(!gameMode) return null;

    if(!s_pInstance)
        s_pInstance = SCR_Badger_BaseGameMode.Cast(gameMode.FindComponent(SCR_Badger_BaseGameMode));

    return s_pInstance;
}
</code></pre>
<h2 id="spawn-areas"><a class="header" href="#spawn-areas">Spawn Areas</a></h2>
<p>We need the ability to both register and unregister a spawn area.</p>
<pre><code class="language-csharp">private ref map&lt;Faction, ref array&lt;SCR_Badger_SpawnArea&gt;&gt; m_FactionSpawnAreas = new map&lt;Faction, ref array&lt;SCR_Badger_SpawnArea&gt;&gt;();

void RegisterSpawnArea(SCR_Badger_SpawnArea spawnArea)
{
    if(!GetGame().GetFactionManager())
    {
        Print(&quot;Could not locate faction manager. Unable to register spawn area&quot;, LogLevel.ERROR);
        return;
    }

    Faction areaFaction = GetGame().GetFactionManager().GetFactionByKey(spawnArea.GetAffiliatedFactionKey());

    if(!areaFaction) return;

    if(!m_FactionSpawnAreas.Contains(areaFaction))
        m_FactionSpawnAreas.Insert(areaFaction, new array&lt;SCR_Badger_SpawnArea&gt;());
    
    m_FactionSpawnAreas.Get(areaFaction).Insert(spawnArea);
    Print(string.Format(&quot;%1 has %2 spawn areas now...&quot;, areaFaction.GetFactionName(), m_FactionSpawnAreas.Get(areaFaction).Count()), LogLevel.DEBUG);
}

void UnregisterSpawnArea(SCR_Badger_SpawnArea spawnArea)
{
    if(!GetGame().GetFactionManager())
    {
        Print(&quot;Could not locate faction manager. Unable to unregister spawn area&quot;, LogLevel.ERROR);
        return;    
    }

    Faction areaFaction = GetGame().GetFactionManager().GetFactionByKey(spawnArea.GetAffiliatedFactionKey());

    if(!areaFaction) return;
    if(!m_FactionSpawnAreas.Contains(areaFaction)) return;

    int indexOf = m_FactionSpawnAreas.Get(areaFaction).Find(spawnArea);

    if(indexOf != -1)
        m_FactionSpawnAreas.Get(areaFaction).Remove(indexOf);
}
</code></pre>
<p>Now that we have the ability to add/remove spawn areas we also need a way to access them!</p>
<pre><code class="language-csharp">// Gets the number of spawn areas that are being tracked for a given faction
int GetSpawnAreaCountFor(FactionKey factionKey)
{
    if(!factionKey) return 0;
    Faction faction = GetGame().GetFactionManager().GetFactionByKey(factionKey);

    if(!faction) return 0;
    if(!m_FactionSpawnAreas.Contains(faction)) return 0;

    return m_FactionSpawnAreas.Get(faction).Count();
}

// Populate a given array with the spawn areas of a given faction (if applicable), and return the # of spawn areas
int GetSpawnAreasFor(notnull array&lt;SCR_Badger_SpawnArea&gt; outAreas, FactionKey factionKey)
{
    if(!factionKey)
    {
        Print(&quot;[SCR_Badger_BaseGameMode] &lt;GetSpawnAreasFor&gt;: FactionKey cannot be null. Returning 0&quot;, LogLevel.ERROR);
        return 0;
    }

    Faction faction = GetGame().GetFactionManager().GetFactionByKey(factionKey);

    if(!faction)
    {
        Print(string.Format(&quot;[SCR_Badger_BaseGameMode] &lt;GetSpawnAreasFor&gt;: Could not locate faction with key %1&quot;, factionKey), LogLevel.ERROR);
        return 0;
    }

    int count = 0;
    foreach(SCR_Badger_SpawnArea spawnArea : m_FactionSpawnAreas.Get(faction))
    {
        outAreas.Insert(spawnArea);
        count++;
    }

    return count;
}

// Return a random spawn area from a given faction
SCR_Badger_SpawnArea GetRandomSpawnAreaFor(FactionKey factionKey)
{
    if(!factionKey)
    {
        Print(&quot;[SCR_Badger_BaseGameMode] &lt;GetRandomSpawnAreaFor&gt;: Faction key is null. Returning nothing&quot;);
        return null;
    }

    Faction faction = GetGame().GetFactionManager().GetFactionByKey(factionKey);

    if(!faction)
    {
        Print(string.Format(&quot;[SCR_Badger_BaseGameMode] &lt;GetRandomSpawnAreaFor&gt;: Could not locate faction with key %1&quot;, factionKey), LogLevel.ERROR);
        return null;
    }

    if(!m_FactionSpawnAreas.Contains(faction)) return null; // if we're not tracking that faction...

    return m_FactionSpawnAreas.Get(faction).GetRandomElement();
}
</code></pre>
<h2 id="point-of-interest"><a class="header" href="#point-of-interest">Point of interest</a></h2>
<p>Just like our spawn areas we need the same type of API to register, unregister, retrieve and such....</p>
<pre><code class="language-csharp">private ref array&lt;SCR_Badger_POI&gt; m_PointsOfInterest = {};

// Retrieve # of POIs being tracked
int PointsOfInterestCount() { return m_PointsOfInterest.Count(); }

// Loads points of interest into `outArray` and returns # of POIs
int GetPointsOfInterest(notnull array&lt;SCR_Badger_POI&gt; outArray)
{
    int count = 0;

    foreach(SCR_Badger_POI area : m_PointsOfInterest)
    {
        outArray.Insert(area);
        count++;
    }

    return count;
}

// Return a random POI.
SCR_Badger_POI GetRandomPointOfInterest()
{
    if(m_PointsOfInterest.IsEmpty()) return null;
    return m_PointsOfInterest.GetRandomElement();
}

// Retrieve the areas held by a given faction, in `areas`. Return # of POIs held.
int GetPointsOfInterestHeldBy(notnull array&lt;SCR_Badger_POI&gt; areas, FactionKey factionKey)
{
    int count = 0;

    foreach(SCR_Badger_POI area : m_PointsOfInterest)
    {
        if(area.GetOwningFaction().GetFactionKey() != factionKey)
            continue;
        
        areas.Insert(area);
        count++;
    }

    return count;
}

// Registers a POI to the game mode
void RegsterPOI(SCR_Badger_POI area)
{
    if(!area) return;
    m_PointsOfInterest.Insert(area);
}

// Unregisters / removes POI from game mode
void UnregisterPOI(SCR_Badger_POI area)
{
    if(!area) return;
    int indexOf = m_PointsOfInterest.Find(area);

    if(indexOf != -1)
        m_PointsOfInterest.Remove(indexOf);
}
</code></pre>
<h2 id="in-closing"><a class="header" href="#in-closing">In closing</a></h2>
<p>That's pretty much all the functionality we need in our basic gamemode system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faction-config"><a class="header" href="#faction-config">Faction Config</a></h1>
<p>To eliminate the attribute/property soup we'll utilize config files! This also makes swapping out a set of values a bit cleaner / easier in the long run as well.</p>
<p>We may even simplify it further by separating site-compositions into another config! </p>
<pre><code class="language-csharp">[BaseContainerProps(configRoot: true)] // This is required in order to inform the engine this is a config file
class Badger_AttackDefend_FactionConfig
{
    // All the values we want in our config go here
    [Attribute(&quot;&quot;, UIWidgets.EditBox, &quot;Faction Key&quot;, category: &quot;Basic Info&quot;)]
	private FactionKey m_pFactionKey;		
	
	[Attribute(&quot;1&quot;, UIWidgets.Slider, desc: &quot;Number of groups to maintain overtime&quot;, params: &quot;1, 100, 1&quot;, category: &quot;Basic Info&quot;)]
	private int m_iNumberOfGroups;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Group Prefabs to spawn&quot;, params: &quot;et&quot;, category: &quot;Basic Info&quot;)]
	private ref array&lt;ResourceName&gt; m_aGroupPrefabs;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Small road site prefabs of controlled areas&quot;, category: &quot;Sites: Road Prefabs&quot;)]
	private ref array&lt;ResourceName&gt; m_aSmallRoadSitePrefabs;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Medium road site prefabs of controlled areas&quot;, category: &quot;Sites: Road Prefabs&quot;)]
	private ref array&lt;ResourceName&gt; m_aMediumRoadSitePrefabs;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Large road site prefabs of controlled areas&quot;, category: &quot;Sites: Road Prefabs&quot;)]
	private ref array&lt;ResourceName&gt; m_aLargeRoadSitePrefabs;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Small site prefabs of controlled areas&quot;, category: &quot;Sites: Site Prefabs&quot;)]
	private ref array&lt;ResourceName&gt; m_aSmallSitePrefabs;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Medium site prefabs of controlled areas&quot;, category: &quot;Sites: Site Prefabs&quot;)]
	private ref array&lt;ResourceName&gt; m_aMediumSitePrefabs;
	
	[Attribute(&quot;&quot;, UIWidgets.ResourcePickerThumbnail, desc: &quot;Large site prefabs of controlled areas&quot;, category: &quot;Sites: Site Prefabs&quot;)]
	private ref array&lt;ResourceName&gt; m_aLargeSitePrefabs;
	
	[Attribute(&quot;1&quot;, UIWidgets.CheckBox, desc: &quot;Cares about Points of Interest&quot;, category: &quot;POI&quot;)]
	private bool m_CaresAboutPointsOfInterest;
	
	FactionKey GetFactionKey() { return m_pFactionKey; }
	int GetNumberOfGroups() { return m_iNumberOfGroups; }
	bool CaresAboutPointsOfInterest() { return m_CaresAboutPointsOfInterest; }

	/*
		Since we're only using this to obtain random elements from these arrays we'll
		create that functionality and expose it versus exposing our arrays directly
	*/
	ResourceName GetRandomGroupPrefab() 
	{ 
		if(!m_aGroupPrefabs || m_aGroupPrefabs.IsEmpty()) return ResourceName.Empty;		
		return m_aGroupPrefabs.GetRandomElement(); 
	}
	
	ResourceName GetRandomSmallCheckpointPrefab() 
	{ 
		if(!m_aSmallRoadSitePrefabs || m_aSmallRoadSitePrefabs.IsEmpty()) return ResourceName.Empty;
		return m_aSmallRoadSitePrefabs.GetRandomElement(); 
	}
	
	ResourceName GetRandomMediumCheckpointPrefab() 
	{ 
		if(!m_aMediumRoadSitePrefabs || m_aMediumRoadSitePrefabs.IsEmpty()) return ResourceName.Empty;
		return m_aMediumRoadSitePrefabs.GetRandomElement(); 
	}
	
	ResourceName GetRandomLargeCheckpointPrefab() 
	{ 
		if(!m_aLargeRoadSitePrefabs || m_aLargeRoadSitePrefabs.IsEmpty()) return ResourceName.Empty;
		return m_aLargeRoadSitePrefabs.GetRandomElement(); 
	}
	
	ResourceName GetRandomSmallSitePrefab() 
	{
		if(!m_aSmallSitePrefabs || m_aSmallSitePrefabs.IsEmpty()) return ResourceName.Empty;
		 return m_aSmallSitePrefabs.GetRandomElement(); 
	}
	
	ResourceName GetRandomMediumSitePrefab() 
	{ 
		if(!m_aMediumSitePrefabs || m_aMediumSitePrefabs.IsEmpty()) return ResourceName.Empty;
		return m_aMediumSitePrefabs.GetRandomElement(); 
	}
	
	ResourceName GetRandomLargeSitePrefab() 
	{ 
		if(!m_aLargeSitePrefabs || m_aLargeSitePrefabs.IsEmpty()) return ResourceName.Empty;
		return m_aLargeSitePrefabs.GetRandomElement(); 
	}
}
</code></pre>
<h1 id="config-creation"><a class="header" href="#config-creation">Config Creation</a></h1>
<p>In the resource browser we can now </p>
<p><code>Right Click --&gt; Config File --&gt; &quot;give it a name you want&quot; --&gt; Badger_AttackDefend_FactionConfig</code></p>
<p><img src="attackdefend/../imgs/attackdefend/config-creation.png" alt="Config File" /></p>
<h1 id="config-usage"><a class="header" href="#config-usage">Config Usage</a></h1>
<p>Using our config is actually simple... First we'll want to expose our config to the editor, and limit the config class type to our custom one! We don't want just ANY config...</p>
<p>To limit the class-type we need to set the <code>conf class</code> equal to the target type. In our case it's <code>Badger_AttackDefend_FactionConfig</code>.</p>
<pre><code class="language-csharp">[Attribute(&quot;&quot;, UIWidgets.Object, params: &quot;conf class=Badger_AttackDefend_FactionConfig&quot;, category: &quot;Configs&quot;)]
private ref Badger_AttackDefend_FactionConfig m_defendingFactionConfig;
</code></pre>
<p>Unfortunately I wasn't able to get this working as an array. Would have been nice in certain use-cases to add multiple configs for something. Oh well... Could also be possible and I just didn't figure it out yet.</p>
<p><img src="attackdefend/../imgs/attackdefend/config-usage.png" alt="Config Usage" /></p>
<p>By default, the property will be empty and it'll let you create a config item. Or, you can simply drag and drop an existing config from the <code>Resource Browser</code> onto the <code>property</code>. </p>
<p><img src="attackdefend/../imgs/attackdefend/config-view.png" alt="Config View" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn-area"><a class="header" href="#spawn-area">Spawn Area</a></h1>
<p>Our spawn area needs to register itself to our basic game mode <code>SCR_Badger_BaseGameMode</code>. This allows other subsystems to utilize our spawn area!</p>
<p>Not a lot of stuff is needed here....</p>
<pre><code class="language-csharp">[EntityEditorProps(category: &quot;GameScripted/GameMode/Badger&quot;, description: &quot;Defines a spawn area for a given side&quot;)]
class SCR_Badger_SpawnAreaClass : SCR_SpawnAreaClass
{
}

class SCR_Badger_SpawnArea : SCR_SpawnArea
{
    FactionKey GetFaction() { return GetAffiliatedFactionKey(); }

    // View figure for more details
    int GetSpawnRadius() { return GetSphereRadius(); }

    protected override void OnInit(IEntity owner)
    {
        super.OnInit(owner);

        if(!GetGame().InPlayMode())
            return;

        // Register
        SCR_Badger_BaseGameMode badger = SCR_Badger_BaseGameMode.GetInstance();

        if(!badger)
        {
            Print(&quot;[SCR_Badger_SpawnArea] &lt;OnInit&gt; Cannot find SCR_Badger_BaseGameMode! Functionality will be limited&quot;, LogLevel.ERROR);
            return;
        }

        badger.RegisterSpawnArea(this);
    }
}
</code></pre>
<p><img src="attackdefend/../imgs/attackdefend/spawn-area-radius.png" alt="Spawn Area Radius" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="point-of-interest-1"><a class="header" href="#point-of-interest-1">Point of Interest</a></h1>
<p>Similar to <code>SCR_Badger_SpawnArea</code> we have a POI. Primary difference is this isn't meant for <code>spawning</code>, but instead is a <code>CaptureArea</code>.</p>
<pre><code class="language-csharp">[EntityEditorProps(category: &quot;GameScripted/GameMode/Badger&quot;, description: &quot;Defines a point of interest for Badger-Systems&quot;)]
class SCR_Badger_POIClass : SCR_CaptureAreaClass
{
}

class SCR_Badger_POI : SCR_CaptureArea
{
	protected override void OnInit(IEntity owner)
	{
		super.OnInit(owner);
		
		if(!GetGame().InPlayMode())
			return;
		
		SCR_Badger_BaseGameMode badger = SCR_Badger_BaseGameMode.GetInstance();
		
		if(!badger)
		{
			Print(&quot;[SCR_Badger_POI] &lt;OnInit&gt;: Was unable to find SCR_Badger_BaseGameMode, functionality will be limited&quot;, LogLevel.ERROR);
			return;
		}
		
		badger.RegisterPOI(this);
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attack-defend-system"><a class="header" href="#attack-defend-system">Attack Defend System</a></h1>
<p>Creating the classic attack/defend scenario with a little bit of a twist.</p>
<p>Since this is essentially a game-mode type we'll create a script which inherits from the <code>SCR_BaseGameModeComponent</code>. This eventually gets attached to a <code>gamemode</code> entity.</p>
<p>To start of we got our AttackDefend class/component. Now I'm not <em>entirely</em> sure why we need two of these things...</p>
<p>The class is obviously what gets exposed in the Enfusion editor but not sure why the other thing is needed??? It works... magic... guess we shouldn't question it...</p>
<pre><code class="language-csharp">[EntityEditorProps(category: &quot;GameScripted/Systems&quot;, description: &quot;Entity that takes care of managing AI spawning.&quot;, color: &quot;0 0 255 255&quot;)]
class SCR_Badger_AttackDefendClass: SCR_BaseGameModeComponentClass
{
};

class SCR_Badger_AttackDefend : SCR_BaseGameModeComponent
{
   // This is where actual code goes
};
</code></pre>
<h1 id="singleton-practice"><a class="header" href="#singleton-practice">Singleton practice</a></h1>
<p>Just like <code>SCR_Badger_BaseGameMode</code> we may have other systems that want to interact with our <code>Attack/Defend</code> gamemode. Thus, we shall utilize the singleton approach for accessing it</p>
<pre><code class="language-csharp">static SCR_Badger_AttackDefend s_pInstance;

static SCR_Badger_AttackDefend GetAttackDefendHandler()
{
    BaseGameMode gameMode = GetGame().GetGameMode();
    if(!gameMode)
        return null;
    
    if(!s_pInstance)
        s_pInstance = SCR_Badger_AttackDefend.Cast(gameMode.FindComponent(SCR_Badger_AttackDefend));
    return s_pInstance;
}
</code></pre>
<h1 id="propetiesattributes"><a class="header" href="#propetiesattributes">Propeties/Attributes</a></h1>
<h3 id="configs"><a class="header" href="#configs">Configs</a></h3>
<p>The two major attributes here will be the <code>Badger_AttackDefend_FactionConfig</code> values. We'll have one for both the defending and attacking factions.</p>
<pre><code class="language-csharp">/*
    Configs make it easier to swap entire sections of data. Versus using a prefab for every variant of Attack/Defend
*/

[Attribute(&quot;{ABE12035F94ABE16}Scripts/Game/Config/Badger_AttackDefend_US.conf&quot;, UIWidgets.Object, params: &quot;conf class=Badger_AttackDefend_FactionConfig&quot;, category: &quot;Configs&quot;)]
private ref Badger_AttackDefend_FactionConfig m_defendingFactionConfig;

[Attribute(&quot;{C2F3ECCF192F855D}Scripts/Game/Config/Badger_AttackDefend_USSR.conf&quot;, UIWidgets.Object, params: &quot;conf class=Badger_AttackDefend_FactionConfig&quot;, category: &quot;Configs&quot;)]
private ref Badger_AttackDefend_FactionConfig m_attackingFactionConfig;
</code></pre>
<p>It is important to note that the GUID/Resource path will certainly vary for you. Once I created the <code>Badger_AttackDefend_FactionConfig</code> class I created 2 files to represent the <code>US</code> and <code>USSR</code>. I assigned the appropriate values in each and would like to use those files as default. To obtain the resource path you see above simply:</p>
<ol>
<li>Right click on config file in the resource browser</li>
<li>Copy Resource Name(s). </li>
<li>Paste the value... done</li>
</ol>
<p>Another important thing to note is the <code>category</code> value in these attributes. Attributes are grouped by category in the editor which make things a bit cleaner / easier to read.</p>
<h3 id="spawn-settings"><a class="header" href="#spawn-settings">Spawn Settings</a></h3>
<p>As a scenario creator it'd be nice to tweak the number of groups that can spawn at a time. We'll expose a min/max value for the creator to play with.</p>
<p>Additionally, the time between 'wave' spawning should be configurable as well!</p>
<pre><code class="language-csharp">/*
    Spawn settings		
*/
[Attribute(&quot;3&quot;, UIWidgets.Slider, desc: &quot;Number of groups to spawn per interval&quot;, params: &quot;1 100 1&quot;, category: &quot;Spawning&quot;)]
private int m_MinimumSpawnPerInterval;

[Attribute(&quot;10&quot;, UIWidgets.Slider, desc: &quot;Number of groups to spawn per interval&quot;, params: &quot;1 100 1&quot;, category: &quot;Spawning&quot;)]
private int m_MaximumSpawnPerInterval;

// This gives the scenario creator control over how often the spawn wave periods are. 2 - 10 minutes
// For performance reasons, I don't think anything less than 2 minutes is necessary? 
[Attribute(&quot;120&quot;, UIWidgets.Slider, desc: &quot;Number of seconds between spawn-waves&quot;, params: &quot;120 1000 10&quot;, category: &quot;Spawning&quot;)]
private int m_SpawnWaveInterval;
</code></pre>
<p>Note: the <code>slider</code> params are as follows.  &quot;min max increment-or-step&quot;. In this example, <code>120</code> is the minimum value allowed, <code>1000</code> is the maximum value, and when chaning the value we increment/decrement in steps of <code>10</code>.</p>
<h3 id="waypoints"><a class="header" href="#waypoints">Waypoints</a></h3>
<p>Since scenario creators are able to tweak pretty much everything... it's probably a good idea to allow a creator to swap out waypoint prefabs. </p>
<p>For anyone assaulting/attacking, they'll utilize the <code>Attack</code> waypoint prefab. By default it's the search and destroy type.</p>
<p>Defenders will patrol the areas they spawn in, using a combination of <code>Patrol</code> and <code>Cycle</code>. At some point I will integrate the <code>Defend</code> waypoint but haven't gotten around to it yet.</p>
<pre><code class="language-csharp">/*
    As a content-creator, there might be a different waypoint with varying behavior than the 
    default Reforger waypoint. 

    Thus we shall give the creator the option to swap things out for whatever they want
*/

[Attribute(&quot;{B3E7B8DC2BAB8ACC}Prefabs/AI/Waypoints/AIWaypoint_SearchAndDestroy.et&quot;, UIWidgets.ResourceNamePicker, params: &quot;et&quot;, category: &quot;Waypoints&quot;, desc: &quot;When attacking, AI are assigned this waypoint&quot;)]
private ResourceName m_AttackWaypointPrefab;

[Attribute(&quot;{22A875E30470BD4F}Prefabs/AI/Waypoints/AIWaypoint_Patrol.et&quot;, UIWidgets.ResourceNamePicker, params: &quot;et&quot;, category: &quot;Waypoints&quot;, desc: &quot;Defenders use this waypoint type for patrolling the area&quot;)]
private ResourceName m_PatrolWaypointPrefab;

[Attribute(&quot;{93291E72AC23930F}Prefabs/AI/Waypoints/AIWaypoint_Defend.et&quot;, UIWidgets.ResourceNamePicker, params: &quot;et&quot;, category: &quot;Waypoints&quot;, desc: &quot;Defenders use this to defend a specific area&quot;)]
private ResourceName m_DefendWaypointPrefab;

[Attribute(&quot;{35BD6541CBB8AC08}Prefabs/AI/Waypoints/AIWaypoint_Cycle.et&quot;, UIWidgets.ResourceNamePicker, params: &quot;et&quot;, category: &quot;Waypoints&quot;, desc: &quot;AI are given this waypoint when waypoints should repeat&quot;)]
private ResourceName m_CycleWaypointPrefab;
</code></pre>
<p>It is possible these resource names could be the same for you? I'm not sure. They are the default Reforger ones... so... :shrug:</p>
<h3 id="sites"><a class="header" href="#sites">Sites</a></h3>
<p>As a creator, you might end up populating the world yourself. Or you might want to take advantage of the random site-slot population.</p>
<pre><code class="language-csharp">/*
    Use Site Slots 
    
    SiteSlots are designated areas that compositions can be 'spawned' or 'created' at. 
    If enabled, a radius around each spawn area is queried for 'SiteSlots'. Then, those slots 
    are populated with spawn area's corresponding faction prefabs (if provided)
*/
[Attribute(&quot;1&quot;, UIWidgets.CheckBox, desc: &quot;Should site slot prefabs be used?&quot;, category: &quot;Sites&quot;)]
private bool m_PlaceSitesOnStart;

[Attribute(&quot;500&quot;, UIWidgets.Slider, desc: &quot;Distance from spawn location to query&quot;, params: &quot;20 500 10&quot;, category: &quot;Sites&quot;)]
private int m_SiteQueryDistance;	
</code></pre>
<h3 id="local-properties"><a class="header" href="#local-properties">Local properties</a></h3>
<pre><code class="language-csharp">/*
    We need a way to track how many groups are currently in existence
*/
private int m_CurrentAttackingGroupCount = 0;
private int m_CurrentDefendingGroupCount = 0;	

private ref array&lt;SCR_Badger_SpawnArea&gt; defendingSpawnAreas = {};
private ref array&lt;SCR_Badger_SpawnArea&gt; attackingSpawnAreas = {};
private bool usePOI = false;

ref RandomGenerator random;	
FactionManager factionManager;
const string NAME = &quot;[Badger_AttackDefend] &quot;;

/*
    Dictionary of site slots that were discovered. Mapped by their slot type
*/
private bool queryingAttackers = false;
private ref map&lt;SCR_ESlotTypesEnum, ref array&lt;SCR_SiteSlotEntity&gt;&gt; m_defendingSiteSlots = new map&lt;SCR_ESlotTypesEnum, ref array&lt;SCR_SiteSlotEntity&gt;&gt;;
private ref map&lt;SCR_ESlotTypesEnum, ref array&lt;SCR_SiteSlotEntity&gt;&gt; m_attackingSiteSlots = new map&lt;SCR_ESlotTypesEnum, ref array&lt;SCR_SiteSlotEntity&gt;&gt;;  
</code></pre>
<h3 id="oninit"><a class="header" href="#oninit">OnInit</a></h3>
<pre><code class="language-csharp">protected override void OnPostInit(IEntity owner)
{
    if(!GetGame().InPlayMode())
        return;
    
    factionManager = GetGame().GetFactionManager();				
    random = new RandomGenerator();
    
    // Not sure how else to accomplish this?
    // The SpawnAreas will invoke AFTER this game mode despite having PostInit.
    // Therefore, the spawn areas are not actually added by the time this function is called 
    // So, I add a little bit of a delay (10 seconds) to ensure things are good to go
    
    // yes it's probably too much but IDK... someone feel free to critque it.. fix it... halp. 
    GetGame().GetCallqueue().CallLater(InitLater, 10 * 1000, false);
}

protected void InitLater()
{
    // This will initialize our spawn area cache
    int defendAreaCount = SCR_Badger_BaseGameMode.GetInstance().GetSpawnAreasFor(defendingSpawnAreas, m_defendingFactionConfig.GetFactionKey());
    int attackAreaCount = SCR_Badger_BaseGameMode.GetInstance().GetSpawnAreasFor(attackingSpawnAreas, m_attackingFactionConfig.GetFactionKey());
    
    // We want to know how many areas were pulled in for debugging purposes
    Print(string.Format(&quot;Spawn Area Counts: Attacking(%1), Defending(%2)&quot;, attackAreaCount, defendAreaCount), LogLevel.WARNING);
    
    Print(string.Format(&quot;%1 Initializing Sites...&quot;, NAME), LogLevel.WARNING);
    InitializeSites();
    
    usePOI = SCR_Badger_BaseGameMode.GetInstance().PointsOfInterestCount() &gt; 0;
    
    Print(string.Format(&quot;%1 Starting spawn loop...&quot;, NAME), LogLevel.WARNING);
    SpawnLoop();
}
</code></pre>
<h3 id="querysiteslotentities"><a class="header" href="#querysiteslotentities">QuerySiteSlotEntities</a></h3>
<p>This is used for finding SiteSlots. The idea is to give life around the spawn areas.. make it feel like the faction was occupying that area</p>
<pre><code class="language-csharp">/*!
    This is a callback function used when querying entities in a given area. 
    This is particularly used for snagging site-slots 

    It's possible that there is a better way of figuring out the 'Name' portion of the prefab name, however 
    I keep ending up with the 'filepath' which results in me just checking the last portion + file extension.

    This approach does work, but could be improved for sure.
*/
private bool QuerySiteSlotEntities(IEntity entity)
{
    SCR_SiteSlotEntity slotEntity = SCR_SiteSlotEntity.Cast(entity);
    
    if(!slotEntity)
        return true;
    
    string prefabName = slotEntity.GetPrefabData().GetPrefabName();
    Print(string.Format(&quot;%1 Found Slot: %2&quot;, NAME, prefabName), LogLevel.WARNING);
    
    if(prefabName.EndsWith(&quot;E_SlotFlatSmall.et&quot;))
    {
        if(queryingAttackers) AddAttackingSlot(slotEntity, SCR_ESlotTypesEnum.FlatSmall);
        else AddDefendingSlot(slotEntity, SCR_ESlotTypesEnum.FlatSmall);			
    }
    else if(prefabName.EndsWith(&quot;E_SlotFlatMedium.et&quot;))
    {
        if(queryingAttackers) AddAttackingSlot(slotEntity, SCR_ESlotTypesEnum.FlatMedium);
        else AddDefendingSlot(slotEntity, SCR_ESlotTypesEnum.FlatMedium);
    }
    else if(prefabName.EndsWith(&quot;E_SlotFlatLarge.et&quot;))
    {
        if(queryingAttackers) AddAttackingSlot(slotEntity, SCR_ESlotTypesEnum.FlatLarge);
        else AddDefendingSlot(slotEntity, SCR_ESlotTypesEnum.FlatLarge);
    }
    else if(prefabName.EndsWith(&quot;E_SlotRoadSmall.et&quot;))
    {
        if(queryingAttackers) AddAttackingSlot(slotEntity, SCR_ESlotTypesEnum.CheckpointSmall);
        else AddDefendingSlot(slotEntity, SCR_ESlotTypesEnum.CheckpointSmall);			
    }
    else if(prefabName.EndsWith(&quot;E_SlotRoadMedium.et&quot;))
    {
        if(queryingAttackers) AddAttackingSlot(slotEntity, SCR_ESlotTypesEnum.CheckpointMedium);
        else AddDefendingSlot(slotEntity, SCR_ESlotTypesEnum.CheckpointMedium);
    }
    else if(prefabName.EndsWith(&quot;E_SlotRoadLarge.et&quot;))
    {
        if(queryingAttackers) AddAttackingSlot(slotEntity, SCR_ESlotTypesEnum.CheckpointLarge);
        else AddDefendingSlot(slotEntity, SCR_ESlotTypesEnum.CheckpointLarge);
    }		
    
    return true;
}

private void AddDefendingSlot(SCR_SiteSlotEntity slot, SCR_ESlotTypesEnum slotType)
{
    if(!m_defendingSiteSlots.Contains(slotType))
        m_defendingSiteSlots.Insert(slotType, new array&lt;SCR_SiteSlotEntity&gt;());
    
    m_defendingSiteSlots.Get(slotType).Insert(slot);
}

private void AddAttackingSlot(SCR_SiteSlotEntity slot, SCR_ESlotTypesEnum slotType)
{
    if(!m_attackingSiteSlots.Contains(slotType))
        m_attackingSiteSlots.Insert(slotType, new array&lt;SCR_SiteSlotEntity&gt;());
    
    m_attackingSiteSlots.Get(slotType).Insert(slot);
}
</code></pre>
<h3 id="countsides"><a class="header" href="#countsides">CountSides</a></h3>
<p>Need the ability to count AI... could probably be improved... still learning the engine.</p>
<pre><code class="language-csharp">/*!
    Count the number of agents on both sides.
    Update the appropriate values so we can spawn/not spawn groups
*/
private void CountSides()
{
    ref private array&lt;AIAgent&gt; m_entities = {};
    AIWorld aiWorld = GetGame().GetAIWorld();
    aiWorld.GetAIAgents(m_entities);
    
    m_CurrentDefendingGroupCount = 0;
    m_CurrentAttackingGroupCount = 0;
    
    Print(string.Format(&quot;%1 Filtering units from pool of %2&quot;, NAME, m_entities.GetRefCount()), LogLevel.WARNING);
    foreach(AIAgent agent : m_entities)
    {
        SCR_AIGroup group = SCR_AIGroup.Cast(agent);
        
        if(!group)
        {
            SCR_ChimeraAIAgent chimeraAgent = SCR_ChimeraAIAgent.Cast(agent);
            if(agent)
                HandleChimeraAIAgent(chimeraAgent);
            else
                Print(string.Format(&quot;%1 Was not a SCR_AIGroup or SCR_ChimeraAIAgent but a %2&quot;, NAME, agent.ClassName()), LogLevel.WARNING);
            continue;
        }
        else
        {
            HandleAIGroup(group);
            continue;
        }
    }
    
    Print(string.Format(&quot;%1 &lt;Counts&gt;: Defending %2 | Attacking %3&quot;, NAME, m_CurrentDefendingGroupCount, m_CurrentAttackingGroupCount), LogLevel.WARNING);		
}

/*!
    This handles the group portion of AI... the alternative I found were ChimeraAIAgents 	
*/
private void HandleAIGroup(SCR_AIGroup group)
{
    if(!group) return;
    if(group.GetFaction().GetFactionKey() == m_attackingFactionConfig.GetFactionKey())
        m_CurrentAttackingGroupCount += 1;
    else if(group.GetFaction().GetFactionKey() == m_defendingFactionConfig.GetFactionKey())
        m_CurrentDefendingGroupCount += 1;
}

/*! 
    I assume this is what happens when a group deteriorates? Or perhaps a prefab spawns 1 entity?
    There were cases where an AIGroup was no longer an AIGroup but a ChimeraAIAgent 

    This addresses that use-case 
*/
private void HandleChimeraAIAgent(SCR_ChimeraAIAgent agent)
{
    if(!agent) return;
    int factionIndex = agent.GetFaction(agent);
    
    Faction agentFaction = factionManager.GetFactionByIndex(factionIndex);
    
    if(!agentFaction)
    {
        Print(string.Format(&quot;%1 Was unable to locate faction for agent. Faction Index: %2&quot;, NAME, factionIndex), LogLevel.ERROR);
        return;
    }
    
    if(agentFaction.GetFactionKey() == m_attackingFactionConfig.GetFactionKey())
        m_CurrentAttackingGroupCount += 1;
    else if(agentFaction.GetFactionKey() == m_defendingFactionConfig.GetFactionKey())
        m_CurrentDefendingGroupCount += 1;
}
</code></pre>
<h3 id="initializesites"><a class="header" href="#initializesites">InitializeSites</a></h3>
<pre><code class="language-csharp">/*!
    These site slots give life into our world. Make it feel like the occupying / attacking forces are actually 
    there. As if they have purpose. 
*/
private void InitializeSites()
{
    if(!m_PlaceSitesOnStart)	// Only place sites if the scenario creator wanted this behavior
        return;
    
    m_attackingSiteSlots.Clear();
    m_defendingSiteSlots.Clear();				
    
    // We need to query each spawn location for the appropriate sites
    foreach(SCR_Badger_SpawnArea location : defendingSpawnAreas)
    {
        vector center = location.GetOrigin();
        GetGame().GetWorld().QueryEntitiesBySphere(center, m_SiteQueryDistance, QuerySiteSlotEntities, null, EQueryEntitiesFlags.ALL);
    }
    
    // Reuses the Query Callback. Only this time the slots added are given to the attackers
    queryingAttackers = true;
    
    foreach(SCR_Badger_SpawnArea location : attackingSpawnAreas)
    {
        vector center = location.GetOrigin();
        GetGame().GetWorld().QueryEntitiesBySphere(center, m_SiteQueryDistance, QuerySiteSlotEntities, null, EQueryEntitiesFlags.ALL);
    }
    
    // Instantiate our sites!!!
    CreateSites(m_defendingSiteSlots, m_defendingFactionConfig);
    CreateSites(m_attackingSiteSlots, m_attackingFactionConfig);
}

/*!
    Spawn the appropriate sites based on provided site slot dictionary and config

    This config will utilize the site prefab attributes.
*/
private void CreateSites(map&lt;SCR_ESlotTypesEnum, ref array&lt;SCR_SiteSlotEntity&gt;&gt; siteSlots, Badger_AttackDefend_FactionConfig config)
{
    foreach(SCR_ESlotTypesEnum slotType, ref array&lt;SCR_SiteSlotEntity&gt; slots : siteSlots)
    {
        foreach(SCR_SiteSlotEntity slot : slots)
        {
            switch(slotType)
            {
                case SCR_ESlotTypesEnum.FlatSmall:
                {
                    SpawnSite(config.GetRandomSmallSitePrefab(), slot);
                    break;
                }
                case SCR_ESlotTypesEnum.FlatMedium:
                {
                    SpawnSite(config.GetRandomMediumSitePrefab(), slot);
                    break;
                }
                case SCR_ESlotTypesEnum.FlatLarge:
                {
                    SpawnSite(config.GetRandomLargeSitePrefab(), slot);
                    break;
                }
                case SCR_ESlotTypesEnum.CheckpointSmall:
                {
                    SpawnSite(config.GetRandomSmallCheckpointPrefab(), slot);
                    break;
                }
                case SCR_ESlotTypesEnum.CheckpointMedium:
                {
                    SpawnSite(config.GetRandomMediumCheckpointPrefab(), slot);
                    break;
                }
                case SCR_ESlotTypesEnum.CheckpointLarge:
                {
                    SpawnSite(config.GetRandomLargeCheckpointPrefab(), slot);
                    break;
                }
            }
        }
    }
}

/*!
    Spawns a site prefab at a given slot entity 
*/
private void SpawnSite(ResourceName resourceName, SCR_SiteSlotEntity slot)
{
    if(!slot || !resourceName || resourceName.IsEmpty()) return;	// Required parameters cannot be null/empty
    if(slot.IsOccupied()) return;									// Bad things happen if you try spawning a slot that is occupied
            
    /*
        Each site slot has a rotation applied to it. Appears to be how the world creator wanted things to line up
        So we shall takes this into consideration and apply the Y rotation to each composition we spawn
    
        So far this seems to work as intended!
    */
    vector angles = slot.GetAngles();
            
    Resource resource = Resource.Load(resourceName);
    
    Print(string.Format(&quot;Creating Site: %1&quot;, resourceName), LogLevel.WARNING);
    slot.SpawnEntityInSlot(resource, angles[1]); // Y angle is #2, which equates to index 1
}
</code></pre>
<h3 id="spawnloop"><a class="header" href="#spawnloop">SpawnLoop</a></h3>
<pre><code class="language-csharp">/*!
    This is our core loop at keeping the system going
*/
private void SpawnLoop()
{
    if(!GetGame().InPlayMode())
        return;		
    
    /*
        Need to count the number of groups that exist per side.
    */
    
    CountSides();
    
    // Can only spawn our groups if their side has spawn areas!		
    if(!attackingSpawnAreas.IsEmpty())
    {
        int count = RandomCountFor(true);
        SpawnGroupsFor(count, m_attackingFactionConfig, attackingSpawnAreas, true);
    }
    
    if(!defendingSpawnAreas.IsEmpty())
    {
        int count = RandomCountFor(false);
        SpawnGroupsFor(count, m_defendingFactionConfig, defendingSpawnAreas, false);
    }
    
    // Infinite loop. This SpawnLoop will run every 'm_SpawnWaveInterval' seconds. 
    GetGame().GetCallqueue().CallLater(SpawnLoop, m_SpawnWaveInterval * 1000, false);		
}

/*!
    Spawns a given count of groups. 
    These groups will spawn at random areas provided by 'spawnAreas'
    If set 'isAttacking' is true, they'll attack random defensive areas. 
    Otherwise, they will patrol around the spawn areas 
*/
private void SpawnGroupsFor(int count, Badger_AttackDefend_FactionConfig config, array&lt;SCR_Badger_SpawnArea&gt; spawnAreas, bool isAttacking=true)
{
    for(int i = 0; i &lt; count; i++)
    {
        // Select a random group prefab
        ResourceName prefabName = config.GetRandomGroupPrefab();
        SCR_Badger_SpawnArea spawnArea = GetActiveSpawnArea(spawnAreas);
        
        if(!spawnArea) continue;
        
        if(config.CaresAboutPointsOfInterest())
        {
            if(Math.RandomInt(0, 100) &gt; 50)
            {
                Spawn(prefabName, spawnArea, isAttacking, true);
                return;
            }
        }		
        
        Spawn(prefabName, spawnArea, isAttacking);
    }
}

/*!
    Selects an active spawn position from a given array. 

    A spawn area can turn off activity if enemies are present. 
    Clearly we don't want warring factions spawning on top of each other

    ... unless.... 
*/
SCR_Badger_SpawnArea GetActiveSpawnArea(array&lt;SCR_Badger_SpawnArea&gt; areas)
{
    int maxRetries = areas.Count();
    SCR_Badger_SpawnArea area = null;
    
    while(maxRetries &gt; 0)
    {
        area = areas.GetRandomElement();
        if(area.CanSpawn())
            return area;
        maxRetries--;
    }
    
    return null;
}

/*!
    Spawn a group prefab at a given spawn area. If set to attack they'll attack a random defensive area
*/
private bool Spawn(ResourceName prefab, SCR_Badger_SpawnArea spawnArea, bool isAttacking=true, bool sendToPOI=false)
{
    if(!prefab || !spawnArea) return false;
    
    Resource resource = Resource.Load(prefab);
    EntitySpawnParams params();
    
    // position of spawn point 
    vector mat[4];
    spawnArea.GetWorldTransform(mat);
    
    vector position = mat[3];
    
    // We need to generate a random position in area 
    position = random.GenerateRandomPointInRadius(0, spawnArea.GetSpawnRadius(), position);
    position[1] = spawnArea.GetWorld().GetSurfaceY(position[0], position[2]);
    mat[3] = position;
    
    // Update spawm params
    params.TransformMode = ETransformMode.WORLD;
    params.Transform = mat;
    
    SCR_AIGroup newEntity = SCR_AIGroup.Cast(GetGame().SpawnEntityPrefab(resource, GetGame().GetWorld(), params));
    if(!newEntity) return false;
    
    newEntity.SetFlags(EntityFlags.VISIBLE, true);
    
    // Points of interest take presedence
    if(sendToPOI)
    {
        SetAttackPOIFor(newEntity);
        return true;
    }
    
    // If on the offensive, attacking team will attack the defending team
    if(isAttacking)
        SetAttackWaypointFor(newEntity);
    else
    // Otherwise, defenders will patrol the their spawn areas
        CreatePatrolPathFor(newEntity, defendingSpawnAreas);
    return true;
}

/*!
    Calculates the amount of groups that can be spawned for the current interval. 
    Attempts to make sure we don't go &quot;over too much&quot; with our group counts
*/
private int RandomCountFor(bool attackingTeam = true)
{
    int minimum = m_MinimumSpawnPerInterval;
    int maximum = m_MaximumSpawnPerInterval;
    int difference = 0;
    
    if(attackingTeam) difference = m_attackingFactionConfig.GetNumberOfGroups() - m_CurrentAttackingGroupCount;
    else difference = m_defendingFactionConfig.GetNumberOfGroups() - m_CurrentDefendingGroupCount;
    
    if(difference &lt;= 0) return 0;
    
    maximum = Math.Ceil(Math.Min(maximum, difference));
    return Math.RandomInt(minimum, Math.Max(1, maximum));
}

/*!
    \param point acts as the center point
    \param radius of circle 

    Returns a random position in a sphere/circular area
*/
private vector RandomPositionAround(IEntity point, int radius)
{
    vector mat[4];
    point.GetWorldTransform(mat);
    vector position = mat[3];
    position = random.GenerateRandomPointInRadius(0, radius, position);
    return position;
}

/*!
    Loads the waypoint prefab so it's ready to use
*/
private AIWaypoint CreateWaypoint(ResourceName waypointPrefab)
{
    Resource resource = Resource.Load(waypointPrefab);
    if(!resource) return null;
    
    AIWaypoint wp = AIWaypoint.Cast(GetGame().SpawnEntityPrefab(resource));
    
    return wp;
}

/*!
    Creates a patrol path for a given group. Selects points within designated areas to patrol.
    It is possible to patrol area to area
*/
private void CreatePatrolPathFor(SCR_AIGroup group, array&lt;SCR_Badger_SpawnArea&gt; areas)
{
    int waypointCount = Math.RandomInt(2, 6);
    for(int i = 0; i &lt; waypointCount; i++)
    {
        SCR_Badger_SpawnArea area = areas.GetRandomElement();
        AIWaypoint waypoint = CreateWaypoint(m_PatrolWaypointPrefab);
        
        if(!waypoint)
            break;
        
        vector position = RandomPositionAround(area, 100);
        waypoint.SetOrigin(position);
        group.AddWaypoint(waypoint);
    }
    
    AIWaypoint cycle = CreateWaypoint(m_CycleWaypointPrefab);
    if(!cycle) return;
    cycle.SetOrigin(group.GetOrigin());
    group.AddWaypoint(cycle);
}

/*!
    Sets a group to attack a random defensive area
*/
private void SetAttackWaypointFor(SCR_AIGroup group)
{
    if(!group) return;
    
    
    AIWaypoint waypoint = CreateWaypoint(m_AttackWaypointPrefab);
    if(!waypoint) return;
    
    waypoint.SetOrigin(defendingSpawnAreas.GetRandomElement().GetOrigin());
    group.AddWaypoint(waypoint);
}

private void SetAttackPOIFor(SCR_AIGroup group)
{
    if(!group) return;
    
    AIWaypoint waypoint = CreateWaypoint(m_AttackWaypointPrefab);
    if(!waypoint) return;
    waypoint.SetOrigin(SCR_Badger_BaseGameMode.GetInstance().GetRandomPointOfInterest().GetOrigin());
    group.AddWaypoint(waypoint);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
